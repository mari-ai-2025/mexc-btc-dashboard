<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MEXC BTC Dashboard • 1m • C0→C10 • Worker Log</title>
<style>
:root{
  --bg:#0b0f14;
  --ui:#0f1620;
  --card:rgba(255,255,255,0.03);
  --br:rgba(255,255,255,0.10);
  --fg:#e8eef7;
  --muted:#9aa6b2;
  --up:#22c55e;
  --down:#ef4444;
  --flat:#facc15;
  --shadow:0 16px 40px rgba(0,0,0,0.45);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial}
.container{min-height:100vh;display:flex;flex-direction:column}
.header{
  background:linear-gradient(180deg,var(--ui),var(--bg));
  border-bottom:1px solid rgba(255,255,255,0.08);
  padding:10px 12px 12px;
}
.topline{
  max-width:min(1500px,100%);
  margin:0 auto;
  display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
}
.symbol{font-size:11px;letter-spacing:.12em;text-transform:uppercase;color:var(--muted)}
.updated{font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center;white-space:nowrap}
.price-row{display:flex;justify-content:center;align-items:baseline;gap:10px;margin:10px 0 12px}
.price{font-size:clamp(46px,6.6vw,108px);font-weight:900;line-height:1;font-variant-numeric:tabular-nums}
.arrow{font-size:clamp(30px,4.8vw,86px);font-weight:900;line-height:1}
.up{color:var(--up)} .down{color:var(--down)} .flat{color:var(--flat)}

.topgrid{
  max-width:min(1500px,100%);
  margin:0 auto;
  display:grid;
  grid-template-columns: 380px 1fr;
  gap:10px;
}
@media (max-width:980px){ .topgrid{grid-template-columns:1fr} }

.widget{
  border:1px solid rgba(255,255,255,0.08);
  background:var(--card);
  border-radius:14px;
  padding:10px 12px;
  backdrop-filter:blur(6px);
}
.wtitle{font-size:11px;color:var(--muted);letter-spacing:.10em;text-transform:uppercase;margin-bottom:8px}
.wbody{display:flex;flex-direction:column;gap:6px;font-size:13px}
.wrow{display:flex;justify-content:space-between;gap:10px}
.k{color:var(--muted)} .v{font-weight:900}

.tagrow{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end}
.tag{
  display:inline-flex;gap:8px;align-items:center;
  padding:6px 10px;border-radius:999px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(0,0,0,0.22);
  font-size:12px;color:var(--muted);
}
.tag b{color:var(--fg)}
.tag.good{border-color:rgba(34,197,94,0.35)}
.tag.bad{border-color:rgba(239,68,68,0.35)}
.tag.neu{border-color:rgba(255,255,255,0.14)}

.chart{
  border:1px solid rgba(255,255,255,0.08);
  background:var(--card);
  border-radius:14px;
  padding:10px 12px;
  overflow:hidden;
}
.chartHead{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px;flex-wrap:wrap}
.chartTitle{font-size:11px;letter-spacing:.10em;text-transform:uppercase;color:var(--muted)}
#cv{
  width:100%;
  height:360px;
  display:block;
  border-radius:12px;
  background:rgba(0,0,0,0.18);
  border:1px solid rgba(255,255,255,0.10);
  touch-action:none;
  cursor:grab;
}
#cv:active{cursor:grabbing}
.notechips{margin-top:8px;display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
.notechips .chip{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(0,0,0,0.18)}
@media (max-width:520px){ .notechips{display:none} #cv{height:420px} }

.section{
  width:min(1500px,calc(100vw - 24px));
  margin:12px auto 16px;
  padding:0 12px;
}
.panel{
  background:rgba(18,27,38,0.92);
  border:1px solid rgba(255,255,255,0.08);
  border-radius:16px;
  box-shadow:var(--shadow);
  overflow:hidden;
}
.panelHead{
  display:flex;align-items:center;justify-content:space-between;gap:12px;
  padding:10px 12px;background:rgba(255,255,255,0.04);
  border-bottom:1px solid rgba(255,255,255,0.08);
}
.panelTitle{font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:var(--muted)}
.panelBody{padding:12px}
.grid2{display:grid;grid-template-columns:1.2fr 1fr;gap:12px}
@media (max-width:900px){ .grid2{grid-template-columns:1fr} }

.card{
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.03);
  border-radius:14px;
  padding:12px;
}
.big{
  display:flex;justify-content:space-between;gap:12px;align-items:center;
  padding:12px 14px;border-radius:16px;border:1px solid rgba(255,255,255,0.14);
  background:rgba(0,0,0,0.18);
}
.big.good{border-color:rgba(34,197,94,0.35);background:rgba(34,197,94,0.12)}
.big.bad{border-color:rgba(239,68,68,0.35);background:rgba(239,68,68,0.12)}
.big.mid{border-color:rgba(250,204,21,0.28);background:rgba(250,204,21,0.10)}
.bigL{display:flex;flex-direction:column;gap:4px}
.bigLabel{font-size:12px;letter-spacing:.10em;text-transform:uppercase;color:var(--muted)}
.bigState{font-size:28px;font-weight:1000}
.bigSub{font-size:12px;color:var(--muted);font-weight:800}
.bigR{display:flex;flex-direction:column;align-items:flex-end;gap:6px}
.kpi{display:flex;gap:8px;align-items:baseline}
.kpi .num{font-size:26px;font-weight:1000}
.kpi .unit{font-size:12px;color:var(--muted);font-weight:800}

.miniGrid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
@media (max-width:520px){ .miniGrid{grid-template-columns:1fr} }
.mini{border:1px solid rgba(255,255,255,0.10);background:rgba(0,0,0,0.18);border-radius:12px;padding:10px 12px}
.mini .t{font-size:11px;letter-spacing:.10em;text-transform:uppercase;color:var(--muted);margin-bottom:8px}
.mini .row{display:flex;justify-content:space-between;gap:10px;font-size:13px}
.mini .row b{font-weight:1000}

.footer{
  width:min(1500px,calc(100vw - 24px));
  margin:0 auto 18px;padding:0 12px;
  color:var(--muted);font-size:12px;text-align:center;
}
</style>
</head>
<body>
<div class="container">

  <div class="header">
    <div class="topline">
      <div class="symbol">MEXC Futures • BTC_USDT • 1m • C0→C10 • Worker Log</div>
      <div class="updated">
        <span>Updated:</span> <span id="time">—</span>
        <span style="opacity:.6">•</span>
        <span>Feed:</span> <span id="feed" class="flat">Booting…</span>
      </div>
    </div>

    <div class="price-row">
      <div id="price" class="price flat">—</div>
      <div id="arrow" class="arrow flat">●</div>
    </div>

    <div class="topgrid">
      <div style="display:flex;flex-direction:column;gap:10px">
        <div class="widget">
          <div class="wtitle">Market</div>
          <div class="wbody">
            <div class="wrow"><span class="k">Last</span><span class="v" id="last">—</span></div>
            <div class="wrow"><span class="k">Δ 1m</span><span class="v" id="chg1m">—</span></div>
            <div class="wrow"><span class="k">Δ 3m</span><span class="v" id="chg3m">—</span></div>
            <div class="wrow"><span class="k">Δ 5m</span><span class="v" id="chg5m">—</span></div>
            <div class="wrow"><span class="k">Δ 10m</span><span class="v" id="chg10m">—</span></div>
          </div>
        </div>

        <div class="widget">
          <div class="wtitle">Engine</div>
          <div class="wbody">
            <div class="wrow"><span class="k">WS</span><span class="v" id="wsState">—</span></div>
            <div class="wrow"><span class="k">REST</span><span class="v" id="restState">—</span></div>
            <div class="wrow"><span class="k">Last Close</span><span class="v" id="lastClose">—</span></div>
            <div class="wrow"><span class="k">Logger</span><span class="v" id="logState">—</span></div>
          </div>
        </div>

        <div class="widget">
          <div class="wtitle">Active Trade</div>
          <div class="wbody">
            <div class="wrow"><span class="k">State</span><span class="v" id="tState">—</span></div>
            <div class="wrow"><span class="k">Dir</span><span class="v" id="tDir">—</span></div>
            <div class="wrow"><span class="k">Entry (C0)</span><span class="v" id="tEntry">—</span></div>
            <div class="wrow"><span class="k">End (C10)</span><span class="v" id="tEnd">—</span></div>
          </div>
        </div>
      </div>

      <div class="chart">
        <div class="chartHead">
          <div class="chartTitle">Chart • 1m • EMA9/21 + KAMA • C0/C10 markers</div>
          <div class="tagrow">
            <span class="tag neu" id="trendTag">Trend: <b>—</b></span>
            <span class="tag neu" id="setupTag">Setup: <b>—</b></span>
            <span class="tag neu">Drag: <b>Pan</b> • Wheel: <b>Zoom</b> • Dbl-click: <b>Reset</b></span>
          </div>
        </div>
        <canvas id="cv"></canvas>
        <div class="notechips">
          <span class="chip">Right pad: 30%</span>
          <span class="chip">Entry only on closed candle</span>
          <span class="chip">C10 settles after 10 closed candles</span>
        </div>
      </div>
    </div>
  </div>

  <div class="section">
    <div class="panel">
      <div class="panelHead">
        <div class="panelTitle">1m Trend + Signal (Close-Only)</div>
        <div class="tag neu" id="pill">Warming…</div>
      </div>

      <div class="panelBody">
        <div class="grid2">
          <div class="card">
            <div id="trendBox" class="big mid">
              <div class="bigL">
                <div class="bigLabel">Trend</div>
                <div class="bigState" id="trendState">—</div>
                <div class="bigSub" id="trendWhy">—</div>
              </div>
              <div class="bigR">
                <div class="kpi"><span class="num" id="score">—</span><span class="unit">/100</span></div>
                <div class="bigSub" id="trendAt">—</div>
              </div>
            </div>

            <div class="miniGrid">
              <div class="mini">
                <div class="t">Filters</div>
                <div class="row"><span class="k">Vol z</span><b id="volz">—</b></div>
                <div class="row"><span class="k">Stretch</span><b id="stretch">—</b></div>
              </div>
              <div class="mini">
                <div class="t">Pullback</div>
                <div class="row"><span class="k">State</span><b id="pb">—</b></div>
                <div class="row"><span class="k">Break</span><b id="brk">—</b></div>
              </div>
              <div class="mini">
                <div class="t">EMAs</div>
                <div class="row"><span class="k">EMA9</span><b id="ema9v">—</b></div>
                <div class="row"><span class="k">EMA21</span><b id="ema21v">—</b></div>
              </div>
              <div class="mini">
                <div class="t">KAMA</div>
                <div class="row"><span class="k">KAMA</span><b id="kamav">—</b></div>
                <div class="row"><span class="k">Slope</span><b id="kamas">—</b></div>
              </div>
            </div>
          </div>

          <div class="card">
            <div id="opBox" class="big mid">
              <div class="bigL">
                <div class="bigLabel">Action</div>
                <div class="bigState" id="action">WAIT</div>
                <div class="bigSub" id="reason">Warming…</div>
              </div>
              <div class="bigR">
                <div class="kpi"><span class="num" id="opScore">—</span><span class="unit">/100</span></div>
                <div class="bigSub" id="window">Window: 10 candles</div>
              </div>
            </div>

            <div class="miniGrid">
              <div class="mini">
                <div class="t">Logger</div>
                <div class="row"><span class="k">Endpoint</span><b id="logEp">—</b></div>
                <div class="row"><span class="k">Last</span><b id="logLast">—</b></div>
              </div>
              <div class="mini">
                <div class="t">Engine Info</div>
                <div class="row"><span class="k">Symbol</span><b id="sym">BTC_USDT</b></div>
                <div class="row"><span class="k">Interval</span><b>1m</b></div>
              </div>
            </div>

            <div style="margin-top:10px;color:var(--muted);font-size:12px;line-height:1.4">
              Note: This is a signal dashboard. If you want real protection later, add Cloudflare Access in front of Pages.
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <div class="footer" id="footer">
    Engine: booting…
  </div>

</div>

<script>
/* =========================================================
   CONFIG (YOU EDIT THESE)
========================================================= */

// ✅ Set this to your Worker endpoint URL (recommended)
// Example: "https://mexc-btc-logger.yourname.workers.dev"
const LOG_ENDPOINT = "PASTE_WORKER_URL_HERE";

// MEXC Futures (Contract) endpoints
const MEXC_WS  = "wss://contract.mexc.com/edge";
const MEXC_REST_BASE = "https://api.mexc.com/api/v1/contract";
const SYMBOL = "BTC_USDT";
const WS_INTERVAL = "Min1";   // WS: Min1
const REST_INTERVAL = "Min1"; // REST: Min1

// Strategy params (Mode C-ish, close-only)
const EMA_FAST = 9;
const EMA_SLOW = 21;

// KAMA
const KAMA_LEN = 10;
const KAMA_FAST = 2;  // fast smoothing
const KAMA_SLOW = 30; // slow smoothing

// Filters
const VOLZ_LEN = 50;
const MIN_VOLZ = -0.10;     // allow slightly below mean
const MAX_STRETCH_PCT = 0.35; // abs(close - EMA9) % cap to avoid chasing

// Pullback-break relaxed (still structured, EMA aligned)
const PB_LOOKBACK = 6;     // recent swing window
const PB_BODY_MAX = 0.65;  // allow small-to-medium body
const BREAK_WITHIN = 2;    // break within next 2 candles after pullback marked

// Trade outcome
const C10_OFFSET = 10;     // C0 -> C10

/* =========================================================
   UI refs
========================================================= */
const $ = (id)=>document.getElementById(id);
const priceEl = $("price");
const arrowEl = $("arrow");
const timeEl = $("time");
const feedEl = $("feed");
const wsStateEl = $("wsState");
const restStateEl = $("restState");
const lastCloseEl = $("lastClose");
const footerEl = $("footer");

const lastEl = $("last");
const chg1mEl = $("chg1m");
const chg3mEl = $("chg3m");
const chg5mEl = $("chg5m");
const chg10mEl = $("chg10m");

const trendTag = $("trendTag");
const setupTag = $("setupTag");
const pill = $("pill");

const trendBox = $("trendBox");
const trendStateEl = $("trendState");
const trendWhyEl = $("trendWhy");
const scoreEl = $("score");
const trendAtEl = $("trendAt");

const volzEl = $("volz");
const stretchEl = $("stretch");
const pbEl = $("pb");
const brkEl = $("brk");
const ema9El = $("ema9v");
const ema21El = $("ema21v");
const kamaEl = $("kamav");
const kamaSEl = $("kamas");

const opBox = $("opBox");
const actionEl = $("action");
const reasonEl = $("reason");
const opScoreEl = $("opScore");

const logStateEl = $("logState");
const logEpEl = $("logEp");
const logLastEl = $("logLast");
const symEl = $("sym");

const tStateEl = $("tState");
const tDirEl = $("tDir");
const tEntryEl = $("tEntry");
const tEndEl = $("tEnd");

/* =========================================================
   Helpers
========================================================= */
function istTimeStr(){
  return new Date().toLocaleTimeString("en-IN",{timeZone:"Asia/Kolkata"});
}
function fmtPrice(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return "—";
  return n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function setDir(type){
  priceEl.className = "price " + type;
  arrowEl.className = "arrow " + type;
  arrowEl.textContent = type==="up" ? "▲" : type==="down" ? "▼" : "●";
}
function setTag(tagEl, state){
  if (!tagEl) return;
  const b = tagEl.querySelector("b");
  if (b) b.textContent = state;
  tagEl.classList.remove("good","bad","neu");
  if (state === "UP") tagEl.classList.add("good");
  else if (state === "DOWN") tagEl.classList.add("bad");
  else tagEl.classList.add("neu");
}
function setBox(box, type){
  box.classList.remove("good","bad","mid");
  box.classList.add(type);
}

/* =========================================================
   Logger (to Worker)
========================================================= */
logEpEl.textContent = LOG_ENDPOINT.includes("PASTE_") ? "NOT SET" : "SET";
symEl.textContent = SYMBOL;

async function logEvent(payload){
  if (!LOG_ENDPOINT || LOG_ENDPOINT.includes("PASTE_")) {
    logStateEl.textContent = "LOG_ENDPOINT not set";
    return;
  }
  try{
    const r = await fetch(LOG_ENDPOINT, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(payload)
    });
    const text = await r.text();
    logStateEl.textContent = r.ok ? "OK" : ("HTTP " + r.status);
    logLastEl.textContent = istTimeStr();
    // If your Worker returns JSON, you can parse it; keeping it safe:
    // console.log("logEvent resp:", text);
  }catch(e){
    logStateEl.textContent = "POST failed";
    logLastEl.textContent = String(e);
  }
}

/* =========================================================
   Candles + Indicators
========================================================= */
let candles = []; // {tMs, o,h,l,c,v, closed:true}
let emaFast = [];
let emaSlow = [];
let kama = [];
let volWin = [];
let volSum = 0;
let volSumSq = 0;

function emaNext(prev, price, len){
  const k = 2/(len+1);
  return prev + k*(price - prev);
}

function kamaNext(prev, prices, i){
  // KAMA based on Kaufman: ER = change/volatility, SC = (ER*(fastSC-slowSC)+slowSC)^2
  // Using close series.
  const n = KAMA_LEN;
  if (i < n) return prices[i]; // seed early
  const change = Math.abs(prices[i] - prices[i-n]);
  let vol = 0;
  for (let k=i-n+1; k<=i; k++){
    vol += Math.abs(prices[k] - prices[k-1]);
  }
  const er = vol > 0 ? (change / vol) : 0;
  const fastSC = 2/(KAMA_FAST+1);
  const slowSC = 2/(KAMA_SLOW+1);
  const sc = Math.pow(er*(fastSC - slowSC) + slowSC, 2);
  return prev + sc*(prices[i] - prev);
}

function volReset(){
  volWin = []; volSum = 0; volSumSq = 0;
  const start = Math.max(0, candles.length - VOLZ_LEN);
  for (let i=start;i<candles.length;i++){
    const v = candles[i].v;
    volWin.push(v); volSum += v; volSumSq += v*v;
  }
}
function volPush(v){
  volWin.push(v); volSum += v; volSumSq += v*v;
  if (volWin.length > VOLZ_LEN){
    const old = volWin.shift();
    volSum -= old; volSumSq -= old*old;
  }
}
function volZ(v){
  if (volWin.length < VOLZ_LEN) return NaN;
  const mean = volSum / volWin.length;
  const variance = Math.max(1e-12, (volSumSq/volWin.length) - mean*mean);
  const std = Math.sqrt(variance);
  return (v - mean) / (std || 1);
}

function rebuildIndicators(){
  emaFast = []; emaSlow = []; kama = [];
  if (!candles.length) return;
  let eF = candles[0].c;
  let eS = candles[0].c;
  emaFast.push(eF); emaSlow.push(eS);

  const closes = candles.map(x=>x.c);
  let kPrev = closes[0];
  kama.push(kPrev);

  for (let i=1;i<candles.length;i++){
    eF = emaNext(eF, closes[i], EMA_FAST);
    eS = emaNext(eS, closes[i], EMA_SLOW);
    emaFast.push(eF); emaSlow.push(eS);

    kPrev = kamaNext(kPrev, closes, i);
    kama.push(kPrev);
  }
  volReset();
}

/* =========================================================
   Signal Engine (close-only)
========================================================= */
let activeTrade = null; // { startTMs, dir, entry, endTMs, endIdx, settled:false }
let lastClosedTMs = 0;

// Pullback tracking
let pbState = { armed:false, dir:"", armedAtTMs:0, expiresTMs:0, why:"" };

function candleBodyRatio(c){
  const range = Math.max(1e-9, (c.h - c.l));
  return Math.abs(c.c - c.o)/range;
}
function pctDiff(a,b){ return ((a-b)/Math.max(1e-9,b))*100; }

function computeDeltas(){
  const n = candles.length;
  function setDelta(el, idxBack){
    if (!el) return;
    if (n < idxBack+1){ el.textContent="—"; return; }
    const curr = candles[n-1].c;
    const prev = candles[n-1-idxBack].c;
    const diff = curr - prev;
    const p = (diff/prev)*100;
    const sign = diff>=0?"+":"";
    el.textContent = `${sign}${diff.toFixed(2)} (${sign}${p.toFixed(3)}%)`;
    el.classList.remove("up","down","flat");
    el.classList.add(diff>0?"up":diff<0?"down":"flat");
  }
  setDelta(chg1mEl,1);
  setDelta(chg3mEl,3);
  setDelta(chg5mEl,5);
  setDelta(chg10mEl,10);
}

function updateActiveTradeUI(){
  if (!activeTrade){
    tStateEl.textContent = "NONE";
    tDirEl.textContent = "—";
    tEntryEl.textContent = "—";
    tEndEl.textContent = "—";
    return;
  }
  tStateEl.textContent = activeTrade.settled ? "SETTLED" : "ACTIVE";
  tDirEl.textContent = activeTrade.dir;
  tEntryEl.textContent = `${fmtPrice(activeTrade.entry)} @ ${new Date(activeTrade.startTMs).toLocaleTimeString("en-IN",{timeZone:"Asia/Kolkata"})}`;
  tEndEl.textContent = activeTrade.endTMs ? new Date(activeTrade.endTMs).toLocaleTimeString("en-IN",{timeZone:"Asia/Kolkata"}) : "—";
}

function engineOnClosedCandle(){
  const n = candles.length;
  if (n < Math.max(EMA_SLOW+5, 60)) {
    pill.textContent = `Warming… (${n}/60)`;
    actionEl.textContent = "WAIT";
    reasonEl.textContent = "Need more candles…";
    opScoreEl.textContent = "—";
    setTag(trendTag,"—");
    setTag(setupTag,"—");
    return;
  }

  const i = n-1;
  const c = candles[i];
  const e9 = emaFast[i];
  const e21 = emaSlow[i];
  const k = kama[i];

  ema9El.textContent = fmtPrice(e9);
  ema21El.textContent = fmtPrice(e21);
  kamaEl.textContent = fmtPrice(k);

  // KAMA slope (simple)
  const kSlope = (k - kama[i-3]) / Math.max(1e-9, c.c) * 100;
  kamaSEl.textContent = `${kSlope>=0?"+":""}${kSlope.toFixed(3)}%`;

  // Trend state
  const up = (e9 > e21) && (c.c >= e9);
  const down = (e9 < e21) && (c.c <= e9);
  const trend = up ? "UP" : down ? "DOWN" : "NEUTRAL";
  setTag(trendTag, trend);
  trendStateEl.textContent = trend;
  trendAtEl.textContent = `Updated: ${istTimeStr()}`;

  // Volume z
  const vz = volZ(c.v);
  volzEl.textContent = Number.isFinite(vz) ? vz.toFixed(2) : "—";
  const volOk = Number.isFinite(vz) ? (vz >= MIN_VOLZ) : false;

  // Stretch filter
  const stretchPct = Math.abs(pctDiff(c.c, e9));
  stretchEl.textContent = `${stretchPct.toFixed(3)}%`;
  const stretchOk = stretchPct <= MAX_STRETCH_PCT;

  // Pullback definition (relaxed, EMA aligned):
  // - in UP trend: detect a small/medium-body down candle (pullback) near EMA9, then break above last swing high within 2 candles
  // - in DOWN trend: inverse
  const bodyOk = candleBodyRatio(c) <= PB_BODY_MAX;
  let pb = "—";
  let brk = "—";

  // Build recent swing levels
  const start = Math.max(0, i - PB_LOOKBACK);
  let swingHigh = -Infinity, swingLow = Infinity;
  for (let j=start;j<=i;j++){
    swingHigh = Math.max(swingHigh, candles[j].h);
    swingLow  = Math.min(swingLow,  candles[j].l);
  }

  // Arm pullback
  if (!pbState.armed){
    if (trend === "UP"){
      const pullC = candles[i-1];
      const pullIsDown = pullC.c < pullC.o;
      const pullBodyOk = candleBodyRatio(pullC) <= PB_BODY_MAX;
      const nearE9 = Math.abs(pctDiff(pullC.c, emaFast[i-1])) <= 0.18; // ~0.18% proximity band
      if (pullIsDown && pullBodyOk && nearE9){
        pbState.armed = true;
        pbState.dir = "UP";
        pbState.armedAtTMs = pullC.tMs;
        pbState.expiresTMs = pullC.tMs + (BREAK_WITHIN * 60 * 1000);
        pbState.why = "PB near EMA9";
      }
    } else if (trend === "DOWN"){
      const pullC = candles[i-1];
      const pullIsUp = pullC.c > pullC.o;
      const pullBodyOk = candleBodyRatio(pullC) <= PB_BODY_MAX;
      const nearE9 = Math.abs(pctDiff(pullC.c, emaFast[i-1])) <= 0.18;
      if (pullIsUp && pullBodyOk && nearE9){
        pbState.armed = true;
        pbState.dir = "DOWN";
        pbState.armedAtTMs = pullC.tMs;
        pbState.expiresTMs = pullC.tMs + (BREAK_WITHIN * 60 * 1000);
        pbState.why = "PB near EMA9";
      }
    }
  } else {
    // expire
    if (c.tMs > pbState.expiresTMs){
      pbState = { armed:false, dir:"", armedAtTMs:0, expiresTMs:0, why:"" };
    }
  }

  pb = pbState.armed ? `${pbState.dir} ARMED` : "NO";
  pbEl.textContent = pb;

  // Break confirmation (on close only)
  let breakOk = false;
  if (pbState.armed){
    if (pbState.dir === "UP"){
      // break above swingHigh (from recent window excluding current if you want; keeping simple)
      breakOk = c.c > swingHigh;
      brk = breakOk ? "YES (close>high)" : "NO";
    } else {
      breakOk = c.c < swingLow;
      brk = breakOk ? "YES (close<low)" : "NO";
    }
  } else {
    brk = "—";
  }
  brkEl.textContent = brk;

  // Score
  let score = 0;
  score += trend === "UP" || trend === "DOWN" ? 35 : 0;
  score += volOk ? 20 : 0;
  score += stretchOk ? 15 : 0;
  score += (pbState.armed ? 10 : 0);
  score += (breakOk ? 20 : 0);
  score = Math.round(clamp(score,0,100));
  scoreEl.textContent = String(score);
  opScoreEl.textContent = String(score);

  // Action decision
  let action = "WAIT";
  let reason = "Warming…";
  let setup = "—";

  if (trend === "NEUTRAL") reason = "Trend neutral";
  else if (!volOk) reason = `VOLz < ${MIN_VOLZ}`;
  else if (!stretchOk) reason = "Too stretched";
  else if (!pbState.armed) reason = "No pullback";
  else if (!breakOk) reason = "Waiting break";
  else reason = "Signal OK";

  // Only allow new entry if no active trade
  if (!activeTrade && trend !== "NEUTRAL" && volOk && stretchOk && pbState.armed && breakOk){
    action = pbState.dir === "UP" ? "UP(10)" : "DOWN(10)";
    setup = action;
  } else {
    setup = activeTrade ? "TRADE ACTIVE" : "WAIT";
  }

  actionEl.textContent = action;
  reasonEl.textContent = reason;
  setTag(setupTag, setup.startsWith("UP") ? "UP" : setup.startsWith("DOWN") ? "DOWN" : "NEUTRAL");

  // Trend box style
  if (trend === "UP") { setBox(trendBox,"good"); trendWhyEl.textContent = "EMA9>EMA21 & price>=EMA9"; }
  else if (trend === "DOWN") { setBox(trendBox,"bad"); trendWhyEl.textContent = "EMA9<EMA21 & price<=EMA9"; }
  else { setBox(trendBox,"mid"); trendWhyEl.textContent = "Mixed / crossing"; }

  // Opportunity box style
  if (action.startsWith("UP")) setBox(opBox,"good");
  else if (action.startsWith("DOWN")) setBox(opBox,"bad");
  else setBox(opBox, (!volOk || !stretchOk) ? "bad" : "mid");

  pill.textContent = `TF: 1m • EMA${EMA_FAST}/${EMA_SLOW} • KAMA(${KAMA_LEN}) • Close-only`;

  // ENTRY (C0) on close only
  if (!activeTrade && (action.startsWith("UP") || action.startsWith("DOWN"))){
    const dir = action.startsWith("UP") ? "UP" : "DOWN";
    const startTMs = c.tMs;
    const entry = c.c;

    // determine end candle by time (10 minutes later close time)
    const endTMs = startTMs + (C10_OFFSET * 60 * 1000);

    activeTrade = { startTMs, dir, entry, endTMs, endIdx: null, settled:false };
    pbState = { armed:false, dir:"", armedAtTMs:0, expiresTMs:0, why:"" }; // reset pullback after taking trade
    updateActiveTradeUI();

    const eventId = `ENTRY-${SYMBOL}-${startTMs}-${dir}`;
    logEvent({
      event: "ENTRY",
      exchange: "MEXC",
      symbol: SYMBOL,
      dir,
      entryPrice: entry,
      mode: "CLOSE_ONLY",
      eventId,
      note: `score=${score} volz=${Number.isFinite(vz)?vz.toFixed(2):"na"} stretch=${stretchPct.toFixed(3)}`
    });
  }

  // SETTLE at C10 (close-only, deterministic)
  if (activeTrade && !activeTrade.settled){
    // find candle index whose close time == endTMs (or >=, if some gap)
    const endIdx = candles.findIndex(x => x.tMs === activeTrade.endTMs);
    if (endIdx !== -1){
      activeTrade.endIdx = endIdx;
      const endClose = candles[endIdx].c;
      const win = activeTrade.dir === "UP" ? (endClose > activeTrade.entry) : (endClose < activeTrade.entry);
      const result = win ? "WIN" : "LOSS";
      activeTrade.settled = true;
      updateActiveTradeUI();

      const eventId = `RESULT-${SYMBOL}-${activeTrade.startTMs}-${activeTrade.dir}`;
      logEvent({
        event: "RESULT",
        exchange: "MEXC",
        symbol: SYMBOL,
        dir: activeTrade.dir,
        entryPrice: activeTrade.entry,
        c10Price: endClose,
        result,
        mode: "CLOSE_ONLY",
        eventId,
        note: `C10=${C10_OFFSET} endIdx=${endIdx}`
      });
    }
  }
}

/* =========================================================
   MEXC REST warmup (kline)
========================================================= */
async function warmupREST(limit=220){
  // MEXC contract kline requires start/end seconds, returns arrays in data.*
  const nowSec = Math.floor(Date.now()/1000);
  const end = nowSec;
  const start = nowSec - (limit * 60);
  const url = `${MEXC_REST_BASE}/kline/${SYMBOL}?interval=${REST_INTERVAL}&start=${start}&end=${end}`;

  restStateEl.textContent = "Loading…";
  footerEl.textContent = `Engine: REST ${url}`;

  const res = await fetch(url);
  const j = await res.json();

  if (!j || !j.success || !j.data || !Array.isArray(j.data.time)){
    restStateEl.textContent = "FAIL";
    footerEl.textContent = `Engine: REST fail (non-kline json)`;
    throw new Error("REST warmup failed");
  }

  const t = j.data.time;
  const o = j.data.open;
  const h = j.data.high;
  const l = j.data.low;
  const c = j.data.close;
  const v = j.data.vol ?? j.data.volume ?? j.data.q ?? [];

  candles = t.map((ts, i) => ({
    tMs: Number(ts)*1000,
    o: Number(o[i]),
    h: Number(h[i]),
    l: Number(l[i]),
    c: Number(c[i]),
    v: Number(v[i] ?? 0),
    closed: true
  }));

  rebuildIndicators();
  restStateEl.textContent = "OK";
}

/* =========================================================
   MEXC WS (kline) + ping
========================================================= */
let ws = null;
let pingTimer = null;
let lastPrice = NaN;

function connectWS(){
  feedEl.textContent = "Connecting…";
  feedEl.className = "flat";

  if (ws) try{ ws.close(); }catch{}
  ws = new WebSocket(MEXC_WS);

  ws.onopen = ()=>{
    wsStateEl.textContent = "OPEN";
    feedEl.textContent = "Live";
    feedEl.className = "up";

    // sub.kline Min1
    ws.send(JSON.stringify({
      method: "sub.kline",
      param: { symbol: SYMBOL, interval: WS_INTERVAL },
      gzip: false
    }));

    clearInterval(pingTimer);
    pingTimer = setInterval(()=>{
      if (ws && ws.readyState === 1){
        ws.send(JSON.stringify({ method:"ping" }));
      }
    }, 15000);

    footerEl.textContent = "Engine: WS connected • waiting kline…";
  };

  ws.onmessage = (evt)=>{
    let msg;
    try{ msg = JSON.parse(evt.data); }catch{ return; }

    if (msg.channel === "pong") return;

    if (msg.channel === "push.kline" && msg.data && msg.data.symbol === SYMBOL){
      const d = msg.data;
      const tSec = Number(d.t);
      if (!Number.isFinite(tSec)) return;

      const tMs = tSec*1000;
      const o = Number(d.o), h = Number(d.h), l = Number(d.l), c = Number(d.c);
      const v = Number(d.v ?? d.q ?? 0);

      // top price UI
      if (Number.isFinite(c)){
        if (!Number.isFinite(lastPrice)) setDir("flat");
        else if (c > lastPrice) setDir("up");
        else if (c < lastPrice) setDir("down");
        else setDir("flat");
        lastPrice = c;
        priceEl.textContent = fmtPrice(c);
        lastEl.textContent = fmtPrice(c);
        timeEl.textContent = istTimeStr();
      }

      // update candle array
      const last = candles[candles.length-1];
      const isNew = !last || last.tMs !== tMs;

      if (isNew){
        // close previous candle indicators update (treat each kline push as closed minute for deterministic engine)
        candles.push({ tMs, o, h, l, c, v, closed:true });
        if (candles.length > 600) candles.shift();

        // incremental indicator update
        const i = candles.length-1;
        const close = candles[i].c;

        // EMA
        const prevEF = emaFast[i-1] ?? close;
        const prevES = emaSlow[i-1] ?? close;
        emaFast.push(emaNext(prevEF, close, EMA_FAST));
        emaSlow.push(emaNext(prevES, close, EMA_SLOW));

        // KAMA
        const closes = candles.map(x=>x.c);
        const prevK = kama[i-1] ?? close;
        kama.push(kamaNext(prevK, closes, i));

        // Vol window
        volPush(v);

        lastClosedTMs = tMs;
        lastCloseEl.textContent = new Date(tMs).toLocaleTimeString("en-IN",{timeZone:"Asia/Kolkata"});

        // Run engine on closed candle
        engineOnClosedCandle();

        // redraw
        draw();
        computeDeltas();
        updateActiveTradeUI();

      } else {
        // same timestamp update (should be rare for Min1 but safe)
        last.o = o; last.h = h; last.l = l; last.c = c; last.v = v;
        draw();
      }
    }
  };

  ws.onclose = ()=>{
    wsStateEl.textContent = "CLOSED";
    feedEl.textContent = "Reconnecting…";
    feedEl.className = "flat";
    clearInterval(pingTimer);
    pingTimer = null;
    setTimeout(connectWS, 1500);
  };

  ws.onerror = ()=>{
    wsStateEl.textContent = "ERROR";
    feedEl.textContent = "Error";
    feedEl.className = "down";
  };
}

/* =========================================================
   Chart (Canvas) – pan/zoom, right pad, EMA/KAMA + markers
========================================================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

function resize(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const rect = cv.getBoundingClientRect();
  cv.width  = Math.floor(rect.width * dpr);
  cv.height = Math.floor(rect.height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();
}

const view = {
  panX: 0,
  zoom: 1.0,
  isDown:false,
  lastX:0,
  pinch:null
};

function resetView(){
  view.panX = 0;
  view.zoom = 1.0;
  draw();
}

function draw(){
  const w = cv.getBoundingClientRect().width;
  const h = cv.getBoundingClientRect().height;
  ctx.clearRect(0,0,w,h);

  // background
  ctx.fillStyle = "rgba(0,0,0,0.18)";
  ctx.fillRect(0,0,w,h);

  const n = candles.length;
  if (n < 5) return;

  // visible range
  const rightPad = 0.30;
  const usableW = w * (1 - rightPad);
  const barW = clamp(6 * view.zoom, 3, 18);
  const gap = 2;
  const step = barW + gap;

  // how many bars fit
  const barsFit = Math.floor(usableW / step);
  const end = n;
  const start = Math.max(0, end - barsFit);

  // price scale
  let hi = -Infinity, lo = Infinity;
  for (let i=start;i<end;i++){
    hi = Math.max(hi, candles[i].h);
    lo = Math.min(lo, candles[i].l);
  }
  // add margin
  const pad = (hi-lo)*0.06 || 1;
  hi += pad; lo -= pad;

  function y(p){
    return (h-14) - ((p - lo) / Math.max(1e-9, (hi-lo))) * (h-28);
  }

  // x scale with pan
  const baseX = 10 + view.panX;
  let x = baseX;

  // grid lines
  ctx.strokeStyle = "rgba(255,255,255,0.06)";
  ctx.lineWidth = 1;
  for (let k=0;k<5;k++){
    const yy = 14 + k*(h-28)/4;
    ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(w,yy); ctx.stroke();
  }

  // EMA / KAMA lines
  function drawLine(series, color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    let first=true;
    let xx = baseX;
    for (let i=start;i<end;i++){
      const v = series[i];
      if (!Number.isFinite(v)) { xx += step; continue; }
      const yy = y(v);
      if (first){ ctx.moveTo(xx + barW/2, yy); first=false; }
      else ctx.lineTo(xx + barW/2, yy);
      xx += step;
    }
    ctx.stroke();
  }

  // Candle bodies + wicks
  for (let i=start;i<end;i++){
    const c = candles[i];
    const up = c.c >= c.o;
    const col = up ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";

    // wick
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(x + barW/2, y(c.h));
    ctx.lineTo(x + barW/2, y(c.l));
    ctx.stroke();

    // body
    ctx.fillStyle = col;
    const y1 = y(c.o);
    const y2 = y(c.c);
    const top = Math.min(y1,y2);
    const bh = Math.max(2, Math.abs(y2-y1));
    ctx.fillRect(x, top, barW, bh);

    x += step;
  }

  // overlay EMA/KAMA (subtle)
  drawLine(emaFast, "rgba(255,255,255,0.55)");
  drawLine(emaSlow, "rgba(255,255,255,0.28)");
  drawLine(kama,    "rgba(250,204,21,0.70)");

  // markers for active trade
  if (activeTrade){
    // find start index by time
    const sIdx = candles.findIndex(z => z.tMs === activeTrade.startTMs);
    const eIdx = candles.findIndex(z => z.tMs === activeTrade.endTMs);
    const startInView = sIdx >= start && sIdx < end;
    const endInView = eIdx >= start && eIdx < end;

    function xForIndex(idx){
      return baseX + (idx - start)*step + barW/2;
    }

    // C0
    if (startInView){
      const xx = xForIndex(sIdx);
      const yy = y(candles[sIdx].c);
      ctx.fillStyle = activeTrade.dir==="UP" ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";
      ctx.beginPath(); ctx.arc(xx, yy, 6, 0, Math.PI*2); ctx.fill();

      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.fillRect(xx-18, yy-30, 36, 18);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "12px system-ui";
      ctx.textAlign = "center";
      ctx.fillText("C0", xx, yy-17);
    }

    // C10
    if (endInView){
      const xx = xForIndex(eIdx);
      const yy = y(candles[eIdx].c);
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath(); ctx.arc(xx, yy, 6, 0, Math.PI*2); ctx.fill();

      // WIN/LOSS if settled
      if (activeTrade.settled){
        const endClose = candles[eIdx].c;
        const win = activeTrade.dir==="UP" ? (endClose > activeTrade.entry) : (endClose < activeTrade.entry);
        const label = win ? "WIN" : "LOSS";
        ctx.fillStyle = win ? "rgba(34,197,94,0.95)" : "rgba(239,68,68,0.95)";
        ctx.fillRect(xx-28, yy-30, 56, 18);
        ctx.fillStyle = "rgba(0,0,0,0.90)";
        ctx.font = "12px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(label, xx, yy-17);
      } else {
        ctx.fillStyle = "rgba(0,0,0,0.75)";
        ctx.fillRect(xx-20, yy-30, 40, 18);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.font = "12px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("C10", xx, yy-17);
      }
    }
  }

  // right pad hint (very subtle)
  ctx.fillStyle = "rgba(255,255,255,0.02)";
  ctx.fillRect(usableW, 0, w-usableW, h);
}

/* mouse pan */
cv.addEventListener("mousedown",(e)=>{
  view.isDown = true;
  view.lastX = e.clientX;
},{passive:true});
window.addEventListener("mouseup",()=>{ view.isDown=false; },{passive:true});
window.addEventListener("mousemove",(e)=>{
  if (!view.isDown) return;
  const dx = e.clientX - view.lastX;
  view.lastX = e.clientX;
  view.panX += dx;
  draw();
},{passive:true});

/* wheel zoom */
cv.addEventListener("wheel",(e)=>{
  e.preventDefault();
  const delta = e.deltaY;
  const rect = cv.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const before = view.zoom;
  view.zoom = clamp(view.zoom * (delta > 0 ? 0.92 : 1.08), 0.7, 6);
  const k = view.zoom / before;
  view.panX = (view.panX - mx) * k + mx;
  draw();
},{passive:false});

/* double click reset */
cv.addEventListener("dblclick", resetView, {passive:true});

/* touch pan/pinch + double tap */
cv.addEventListener("touchstart",(e)=>{
  if (e.touches.length===1){
    view.isDown=true; view.lastX=e.touches[0].clientX; view.pinch=null;
  } else if (e.touches.length===2){
    view.isDown=false;
    const a=e.touches[0], b=e.touches[1];
    const dx=a.clientX-b.clientX;
    const dist=Math.sqrt(dx*dx);
    const rect=cv.getBoundingClientRect();
    const midX=((a.clientX+b.clientX)/2)-rect.left;
    view.pinch={dist, midX, startZoom:view.zoom, startPanX:view.panX};
  }
},{passive:false});

cv.addEventListener("touchmove",(e)=>{
  if (e.touches.length===1 && view.isDown){
    e.preventDefault();
    const x=e.touches[0].clientX;
    const dx=x-view.lastX; view.lastX=x;
    view.panX += dx; draw();
  } else if (e.touches.length===2 && view.pinch){
    e.preventDefault();
    const a=e.touches[0], b=e.touches[1];
    const dx=a.clientX-b.clientX;
    const dist=Math.sqrt(dx*dx);
    const ratio = dist / Math.max(1, view.pinch.dist);
    const before = view.zoom;
    view.zoom = clamp(view.pinch.startZoom * ratio, 0.7, 6);
    const mx = view.pinch.midX;
    const k = view.zoom / before;
    view.panX = (view.panX - mx) * k + mx;
    draw();
  }
},{passive:false});

let lastTap=0;
cv.addEventListener("touchend", ()=>{
  const now=Date.now();
  if (now-lastTap<280) resetView();
  lastTap=now;
},{passive:true});

window.addEventListener("resize", resize);

/* =========================================================
   Boot
========================================================= */
async function start(){
  resize();
  footerEl.textContent = "Engine: starting…";
  try{
    await warmupREST(220);
    computeDeltas();
    draw();
    footerEl.textContent = "Engine: REST warmup OK • connecting WS…";
    connectWS();
  }catch(e){
    footerEl.textContent = "Engine: REST failed • still attempting WS…";
    connectWS();
  }
  setInterval(()=>{ timeEl.textContent = istTimeStr(); }, 800);
  updateActiveTradeUI();
  logStateEl.textContent = LOG_ENDPOINT.includes("PASTE_") ? "Disabled" : "Ready";
}
start();
</script>
</body>
</html>
