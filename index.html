<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BTCUSDT • 1m Futures • Pullback → 10 Candles (Dual Mode + Lead Markers)</title>
<style>
:root{
  --bg:#0b0f14;
  --ui:#0f1620;
  --fg:#e8eef7;
  --muted:#9aa6b2;
  --up:#22c55e;
  --down:#ef4444;
  --flat:#facc15;
  --shadow:0 18px 44px rgba(0,0,0,0.50);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial}
.container{min-height:100vh;display:flex;flex-direction:column}
.wrap{width:min(1600px, calc(100vw - 24px));margin:0 auto;padding:0 12px}

/* header */
.header{
  background:radial-gradient(1200px 520px at 28% 10%, rgba(255,255,255,0.06), transparent 60%),
             linear-gradient(180deg,var(--ui),var(--bg));
  border-bottom:1px solid rgba(255,255,255,0.08);
  padding:10px 0 12px;
}
.topline{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
.title{font-size:12px;letter-spacing:.12em;text-transform:uppercase;color:var(--muted)}
.wsPill{
  display:inline-flex;align-items:center;gap:10px;
  padding:8px 12px;border-radius:999px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(0,0,0,0.22);
  font-size:12px;color:var(--muted);
}
.dot{width:10px;height:10px;border-radius:999px;background:rgba(250,204,21,0.90)}
.dot.on{background:rgba(34,197,94,0.90)}
.dot.off{background:rgba(239,68,68,0.90)}
.wsPill b{color:var(--fg)}

.hero{display:flex;align-items:flex-end;justify-content:space-between;gap:14px;flex-wrap:wrap;margin-top:10px}
.priceRow{display:flex;align-items:baseline;gap:10px}
.price{font-size:clamp(54px, 6.8vw, 118px);font-weight:1000;line-height:1;font-variant-numeric:tabular-nums}
.arrow{font-size:clamp(28px, 4.4vw, 86px);font-weight:1000;line-height:1}
.up{color:var(--up)} .down{color:var(--down)} .flat{color:var(--flat)}

.actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.btn{
  appearance:none;border:1px solid rgba(255,255,255,0.14);
  background:rgba(0,0,0,0.22);color:var(--fg);
  padding:10px 12px;border-radius:14px;cursor:pointer;
  font-weight:900;font-size:13px;
}
.btn:hover{border-color:rgba(255,255,255,0.22)}
.btn.warn{border-color:rgba(250,204,21,0.35)}
.btn.danger{border-color:rgba(239,68,68,0.35)}
.btn.good{border-color:rgba(34,197,94,0.35)}
.btn.bad{border-color:rgba(239,68,68,0.35)}

.smallNote{font-size:12px;color:var(--muted);margin-top:6px}

/* stats grid */
.stats{padding:10px 0 0}
.grid{display:grid;gap:10px;grid-template-columns:repeat(4,1fr)}
@media (max-width:1100px){.grid{grid-template-columns:repeat(2,1fr)}}
@media (max-width:560px){.grid{grid-template-columns:1fr}}

.card{
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(0,0,0,0.20);
  border-radius:16px;
  box-shadow:var(--shadow);
  padding:12px 14px;
}
.cardTop{display:flex;align-items:center;justify-content:space-between;gap:10px}
.cardLabel{font-size:12px;letter-spacing:.10em;text-transform:uppercase;color:var(--muted)}
.cardVal{font-size:18px;font-weight:1000}
.sub{font-size:12px;color:var(--muted);margin-top:6px}
.bigVal{font-size:22px;font-weight:1000}
.pill{
  display:inline-flex;align-items:center;gap:8px;
  padding:6px 10px;border-radius:999px;
  border:1px solid rgba(255,255,255,0.14);
  background:rgba(0,0,0,0.22);
  color:var(--muted);font-size:12px;
}
.pill b{color:var(--fg)}
.pill.good{border-color:rgba(34,197,94,0.35)}
.pill.bad{border-color:rgba(239,68,68,0.35)}
.pill.neu{border-color:rgba(255,255,255,0.14)}

/* chart */
.chartWrap{padding:12px 0 16px}
.chartPanel{
  border:1px solid rgba(255,255,255,0.10);
  background:rgba(255,255,255,0.03);
  border-radius:18px;
  box-shadow:var(--shadow);
  overflow:hidden;
}
.chartHead{
  display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  padding:10px 12px;background:rgba(255,255,255,0.04);
  border-bottom:1px solid rgba(255,255,255,0.08);
}
.chartTitle{font-size:12px;letter-spacing:.10em;text-transform:uppercase;color:var(--muted)}
.chips{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;align-items:center}
.chip{
  display:inline-flex;align-items:center;gap:8px;
  padding:7px 10px;border-radius:999px;
  border:1px solid rgba(255,255,255,0.12);
  background:rgba(0,0,0,0.22);
  font-size:12px;color:var(--muted);
}
.chip b{color:var(--fg)}
.chip.good{border-color:rgba(34,197,94,0.35)}
.chip.bad{border-color:rgba(239,68,68,0.35)}
.chip.neu{border-color:rgba(255,255,255,0.14)}

.chartBody{padding:12px}
#cv{
  width:100%;
  height:min(62vh, 660px);
  display:block;
  border-radius:16px;
  background:rgba(0,0,0,0.18);
  border:1px solid rgba(255,255,255,0.10);
  touch-action:none;
  cursor:grab;
}
#cv:active{cursor:grabbing}
.noteRow{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;color:var(--muted);font-size:12px}
.noteRow .chip{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.10);background:rgba(0,0,0,0.18)}
.footer{padding:10px 0 18px;text-align:center;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="wrap">
      <div class="topline">
        <div class="title">BTCUSDT • 1m • Futures • Pullback → 10 Candles • Dual Mode</div>
        <div class="wsPill">
          <span class="dot" id="wsDot"></span>
          <span>WS</span><b id="wsState">—</b>
          <span style="opacity:.6">•</span>
          <span>Live</span><b id="feed">—</b>
          <span style="opacity:.6">•</span>
          <span>Updated</span><b id="time">—</b>
        </div>
      </div>

      <div class="hero">
        <div class="priceRow">
          <div id="price" class="price flat">—</div>
          <div id="arrow" class="arrow flat">●</div>
        </div>
        <div class="actions">
          <button class="btn warn" id="btnMode" type="button" title="Switch between Cleaner (reliable) and Early (heads-up)">Mode: CLEAN</button>
          <button class="btn" id="btnResetView" type="button">Reset View</button>
          <button class="btn danger" id="btnClearTrade" type="button">Clear C0→C10</button>
          <button class="btn good" id="btnManualUp" type="button" title="Manual lead: UP, lock 10 candles">Manual ▲</button>
          <button class="btn bad" id="btnManualDown" type="button" title="Manual lead: DOWN, lock 10 candles">Manual ▼</button>
        </div>
      </div>

      <div class="smallNote" id="status">Starting…</div>

      <div class="stats">
        <div class="grid">
          <div class="card">
            <div class="cardTop"><div class="cardLabel">24H</div><div class="bigVal" id="chg24h">—</div></div>
            <div class="sub">Binance ticker % change</div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Trend</div><div class="bigVal" id="trend">—</div></div>
            <div class="sub"><span class="pill neu" id="trendPill">Warming <b id="warmN">0</b>/60 • Chop <b id="chop">—</b></span></div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Setup</div><div class="bigVal" id="setup">—</div></div>
            <div class="sub"><span class="pill neu" id="setupPill"><b id="modeTag">CLEAN</b> • Score <b id="score">—</b>/100</span></div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Active Lead</div><div class="bigVal" id="active">—</div></div>
            <div class="sub" id="activeSub">C0 — • C10 —</div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Δ1M</div><div class="cardVal" id="d1">—</div></div>
            <div class="sub">Close to close</div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Δ3M</div><div class="cardVal" id="d3">—</div></div>
            <div class="sub">Close to close</div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Δ5M</div><div class="cardVal" id="d5">—</div></div>
            <div class="sub">Close to close</div>
          </div>
          <div class="card">
            <div class="cardTop"><div class="cardLabel">Δ10M</div><div class="cardVal" id="d10">—</div></div>
            <div class="sub">Close to close</div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div class="chartWrap">
    <div class="wrap">
      <div class="chartPanel">
        <div class="chartHead">
          <div class="chartTitle">Chart • 1m candles • EMA20/50 • Pullback lead ▲/▼ (locks 10 candles) • C10 WIN/LOSS</div>
          <div class="chips">
            <span class="chip neu" id="chipTrend">Trend: <b>—</b></span>
            <span class="chip neu" id="chipSetup">Setup: <b>—</b></span>
            <span class="chip neu">Drag: <b>Pan</b> • Wheel: <b>Zoom</b> • Dbl-click: <b>Reset</b></span>
          </div>
        </div>
        <div class="chartBody">
          <canvas id="cv"></canvas>
          <div class="noteRow">
            <span class="chip">Lead arrow appears at C0 when pullback trigger fires (or manual ▲/▼)</span>
            <span class="chip">After a lead, no new lead for 10 candles (C0→C10)</span>
            <span class="chip">C10 shows ● + WIN/LOSS</span>
          </div>
        </div>
      </div>
      <div class="footer">Keep this file as <b>index.html</b> in your repo, then push to GitHub/Cloudflare Pages.</div>
    </div>
  </div>
</div>

<script>
const CONFIG = {
  SYMBOL_REST: "BTCUSDT",
  SYMBOL_WS: "btcusdt",
  KLINE_INTERVAL: "1m",
  EMA_FAST: 20,
  EMA_SLOW: 50,
  VOL_Z_LEN: 50,
  MODES: {
    CLEAN: { MIN_STRENGTH: 65, MAX_CHOP: 65, MIN_VOLZ: -0.10, MIN_SLOPE: 0.010, MIN_BODY: 0.30 },
    EARLY: { MIN_STRENGTH: 45, MAX_CHOP: 72, MIN_VOLZ: -0.25, MIN_SLOPE: 0.006, MIN_BODY: 0.22 }
  }
};
const REST_KLINES = "https://fapi.binance.com/fapi/v1/klines";
const WS_BASE = "wss://fstream.binance.com/ws";

const $ = (id)=>document.getElementById(id);
const priceEl = $("price");
const arrowEl = $("arrow");
const timeEl = $("time");
const feedEl = $("feed");
const wsStateEl = $("wsState");
const wsDot = $("wsDot");
const statusEl = $("status");

const chg24hEl = $("chg24h");
const trendEl = $("trend");
const setupEl = $("setup");
const scoreEl = $("score");
const chopEl = $("chop");
const warmNEl = $("warmN");
const modeTagEl = $("modeTag");

const activeEl = $("active");
const activeSubEl = $("activeSub");

const d1El = $("d1");
const d3El = $("d3");
const d5El = $("d5");
const d10El = $("d10");

const chipTrend = $("chipTrend");
const chipSetup = $("chipSetup");
const trendPill = $("trendPill");
const setupPill = $("setupPill");

const btnResetView = $("btnResetView");
const btnClearTrade = $("btnClearTrade");
const btnMode = $("btnMode");
const btnManualUp = $("btnManualUp");
const btnManualDown = $("btnManualDown");

function istTimeStr(){ return new Date().toLocaleTimeString("en-IN",{timeZone:"Asia/Kolkata"}); }
function fmtPrice(x){
  const n = Number(x);
  if (!Number.isFinite(n)) return "—";
  return n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
}
function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }
function setDir(type){
  priceEl.className = "price " + type;
  arrowEl.className = "arrow " + type;
  arrowEl.textContent = type==="up" ? "▲" : type==="down" ? "▼" : "●";
}
function setChip(chipEl, state){
  const b = chipEl?.querySelector("b");
  if (b) b.textContent = state;
  chipEl.classList.remove("good","bad","neu");
  if (state.startsWith("UP")) chipEl.classList.add("good");
  else if (state.startsWith("DOWN")) chipEl.classList.add("bad");
  else chipEl.classList.add("neu");
}
function setPill(pillEl, type){
  pillEl.classList.remove("good","bad","neu");
  pillEl.classList.add(type);
}
function setTextColored(el, txt, dir){
  el.classList.remove("up","down","flat");
  el.classList.add(dir || "flat");
  el.textContent = txt;
}

/* mode */
const LS_MODE = "btc_dash_mode_v1";
let MODE = (localStorage.getItem(LS_MODE) === "EARLY") ? "EARLY" : "CLEAN";
function applyModeUI(){
  btnMode.textContent = `Mode: ${MODE}`;
  modeTagEl.textContent = MODE;
}
btnMode.addEventListener("click", ()=>{
  MODE = (MODE === "CLEAN") ? "EARLY" : "CLEAN";
  localStorage.setItem(LS_MODE, MODE);
  applyModeUI();
  computeTrendAndSetup();
});
applyModeUI();

/* state */
let lastTickPrice = NaN;
let candles = [];
let emaFast = [];
let emaSlow = [];

/* vol z */
let volWindow=[], volSum=0, volSumSq=0;
function volReset(){
  volWindow=[]; volSum=0; volSumSq=0;
  const start = Math.max(0, candles.length - CONFIG.VOL_Z_LEN);
  for (let i=start;i<candles.length;i++){
    const v=candles[i].volume;
    volWindow.push(v); volSum+=v; volSumSq+=v*v;
  }
}
function volPush(v){
  volWindow.push(v); volSum+=v; volSumSq+=v*v;
  if (volWindow.length > CONFIG.VOL_Z_LEN){
    const old=volWindow.shift();
    volSum-=old; volSumSq-=old*old;
  }
}
function volZ(v){
  if (volWindow.length < CONFIG.VOL_Z_LEN) return NaN;
  const mean = volSum/volWindow.length;
  const variance = Math.max(1e-12, (volSumSq/volWindow.length) - mean*mean);
  const std = Math.sqrt(variance);
  return (v-mean)/(std||1);
}

/* ema */
function emaNext(prev, price, len){
  const k = 2/(len+1);
  return prev + k*(price - prev);
}
function rebuildEMAs(){
  emaFast=[]; emaSlow=[];
  if (!candles.length) return;
  let ef=candles[0].close;
  let es=candles[0].close;
  emaFast.push(ef); emaSlow.push(es);
  for (let i=1;i<candles.length;i++){
    ef=emaNext(ef, candles[i].close, CONFIG.EMA_FAST);
    es=emaNext(es, candles[i].close, CONFIG.EMA_SLOW);
    emaFast.push(ef); emaSlow.push(es);
  }
}

/* deltas */
function formatDelta(curr, prev){
  if (!Number.isFinite(curr) || !Number.isFinite(prev) || prev===0) return {txt:"—",dir:"flat"};
  const diff=curr-prev;
  const p=(diff/prev)*100;
  const sign=diff>=0?"+":"";
  const dir=diff>0?"up":diff<0?"down":"flat";
  return {txt:`${sign}${diff.toFixed(1)} (${sign}${p.toFixed(3)}%)`, dir};
}
function updateDeltas(){
  const n=candles.length;
  if (n<12) { d1El.textContent="—"; d3El.textContent="—"; d5El.textContent="—"; d10El.textContent="—"; return; }
  const curr=candles[n-1].close;
  let o;
  o=formatDelta(curr,candles[n-2].close); setTextColored(d1El,o.txt,o.dir);
  o=formatDelta(curr,candles[n-4].close); setTextColored(d3El,o.txt,o.dir);
  o=formatDelta(curr,candles[n-6].close); setTextColored(d5El,o.txt,o.dir);
  o=formatDelta(curr,candles[n-11].close); setTextColored(d10El,o.txt,o.dir);
}

/* lead tracker */
let pbTrades=[];
const LS_ACTIVE="btc_pb_active_trade_time_v2";
let pbActive=null; // {dir,startTime,startClose, manual:boolean}
function loadActive(){ try{ pbActive=JSON.parse(localStorage.getItem(LS_ACTIVE)||"null"); }catch{ pbActive=null; } }
function saveActive(){ try{ localStorage.setItem(LS_ACTIVE, JSON.stringify(pbActive)); }catch{} }
function clearActive(){ pbActive=null; saveActive(); }
loadActive();

function findIdxByTime(t){
  for (let i=candles.length-1;i>=0;i--) if (candles[i]?.time===t) return i;
  return -1;
}
function detectPullbackTriggerAt(i){
  if (i<1) return null;
  const a=candles[i-1], b=candles[i];
  if(!a||!b) return null;
  const rng=Math.max(1e-9,(a.high-a.low));
  const body=Math.abs(a.close-a.open);
  const smallBody=(body/rng)<0.45;
  if ((a.close<a.open) && smallBody && (b.high>a.high)) return {dir:"UP"};
  if ((a.close>a.open) && smallBody && (b.low<a.low)) return {dir:"DOWN"};
  return null;
}
function maybeAutoLead(){
  const n=candles.length;
  if (n<3) return;
  if (pbActive?.startTime) return;
  const i=n-1;
  const c=candles[i];
  if(!c?.closed) return;
  const trig=detectPullbackTriggerAt(i);
  if(!trig) return;
  pbActive = { dir:trig.dir, startTime:c.time, startClose:c.close, manual:false };
  saveActive();
}
function updateOutcome(){
  if(!pbActive?.startTime) return;
  const sIdx=findIdxByTime(pbActive.startTime);
  if (sIdx<0){ clearActive(); return; }
  const eIdx=sIdx+10;
  if (eIdx>=candles.length) return;
  const endC=candles[eIdx];
  if (!endC?.closed) return;
  const win = pbActive.dir==="UP" ? (endC.close>pbActive.startClose) : (endC.close<pbActive.startClose);
  const outcome=win?"WIN":"LOSS";
  pbTrades.push({dir:pbActive.dir,startTime:pbActive.startTime,startClose:pbActive.startClose,endTime:endC.time,endClose:endC.close,outcome,manual:!!pbActive.manual});
  if (pbTrades.length>50) pbTrades.shift();
  clearActive();
  updateActiveUI();
}
function manualLead(dir){
  const n=candles.length;
  if (n<1) return;
  const c=candles[n-1];
  if (!c?.closed) return;
  if (pbActive?.startTime) return;
  pbActive = { dir, startTime:c.time, startClose:c.close, manual:true };
  saveActive();
  updateActiveUI();
  chart.draw();
}
btnManualUp.addEventListener("click", ()=>manualLead("UP"));
btnManualDown.addEventListener("click", ()=>manualLead("DOWN"));

/* trend + setup */
function computeChopScore(absSlopePct, avgBody5){
  const slopeComp = clamp(1-(absSlopePct/0.050),0,1)*100;
  const bodyComp  = clamp((0.45-avgBody5)/0.45,0,1)*100;
  return Math.round(clamp(0.70*slopeComp + 0.30*bodyComp,0,100));
}
function bodyPct(i){
  const c=candles[i]; if(!c) return 0;
  const r=Math.max(1e-9,(c.high-c.low));
  return Math.abs(c.close-c.open)/r;
}
function avgBody(lastN){
  const n=candles.length; if(n<lastN) return 0;
  let s=0; for(let i=n-lastN;i<n;i++) s+=bodyPct(i);
  return s/lastN;
}
function rangePct(i){
  const c=candles[i]; if(!c) return 0;
  return ((c.high-c.low)/Math.max(1e-9,c.close))*100;
}
function computeTrendAndSetup(){
  const n=candles.length;
  warmNEl.textContent = String(Math.min(60, n));
  if (n<2){
    trendEl.textContent="—";
    setupEl.textContent="WARMING";
    scoreEl.textContent="—";
    chopEl.textContent="—";
    setChip(chipTrend,"—");
    setChip(chipSetup,"—");
    setPill(trendPill,"neu");
    setPill(setupPill,"neu");
    return;
  }
  if (emaFast.length !== n || emaSlow.length !== n) rebuildEMAs();

  const i=n-1;
  const close=candles[i].close;
  const ef=emaFast[i], es=emaSlow[i];
  const ef_5 = emaFast[Math.max(0, i-5)];
  const slopePct=(((ef-ef_5)/Math.max(1e-9,close))*100)/Math.max(1, Math.min(5,i));
  const absSlopePct=Math.abs(slopePct);

  const aboveFast=close>=ef;
  const aboveSlow=close>=es;

  const bodyNow = bodyPct(i);
  const chopScore=computeChopScore(absSlopePct, avgBody(Math.min(5,n)));
  chopEl.textContent=String(chopScore);

  const m = CONFIG.MODES[MODE];
  let trend="NEUTRAL";
  const biasUp=aboveFast && aboveSlow && slopePct>m.MIN_SLOPE;
  const biasDown=(!aboveFast)&&(!aboveSlow)&&slopePct<-m.MIN_SLOPE;

  if (chopScore<m.MAX_CHOP && bodyNow>=m.MIN_BODY && biasUp) trend="UP";
  else if (chopScore<m.MAX_CHOP && bodyNow>=m.MIN_BODY && biasDown) trend="DOWN";

  trendEl.textContent=trend;
  setChip(chipTrend, trend);
  setPill(trendPill, trend==="UP"?"good":trend==="DOWN"?"bad":"neu");

  const vz=volZ(candles[i].volume);

  let strength=0;
  strength += clamp(absSlopePct*1200,0,55);
  strength += clamp(Math.abs((close-ef)/Math.max(1e-9,close))*100*8,0,20);
  strength += (aboveSlow?10:0);
  strength += (bodyNow>=m.MIN_BODY?5:0);
  strength=Math.round(clamp(strength,0,100));

  let sustain=0;
  sustain += clamp(strength*0.65,0,65);
  if (Number.isFinite(vz)) sustain += clamp((vz+0.5)*12,0,18);
  sustain += clamp((1.2-rangePct(i))*10,0,10);
  if (chopScore<m.MAX_CHOP) sustain += 7;
  sustain=Math.round(clamp(sustain,0,100));

  let score=0;
  score += clamp(strength*0.60,0,60);
  score += clamp(sustain*0.25,0,25);
  if (Number.isFinite(vz)) score += clamp((vz+0.5)*8,0,10);
  score += clamp((100-chopScore)*0.05,0,5);
  score=Math.round(clamp(score,0,100));
  scoreEl.textContent=String(score);

  const gateTrend=(trend==="UP"||trend==="DOWN");
  const gateStrength=strength>=m.MIN_STRENGTH;
  const gateChop=chopScore<m.MAX_CHOP;
  const gateVol=Number.isFinite(vz) && vz>=m.MIN_VOLZ;

  let setup="WAIT";
  if (n < 60) setup="WARMING";
  else if (gateTrend && gateStrength && gateChop && gateVol) setup = trend==="UP"?"UP(10m)":"DOWN(10m)";
  else setup="WAIT";

  setupEl.textContent=setup;
  setChip(chipSetup, setup);
  setPill(setupPill, setup.startsWith("UP")?"good":setup.startsWith("DOWN")?"bad":"neu");

  statusEl.textContent = `Mode ${MODE} • Trend ${trend} • Setup ${setup} • Score ${score}/100 • Chop ${chopScore} • Strength ${strength} • VOLz ${Number.isFinite(vz)?vz.toFixed(2):"—"}`;
}

/* active ui */
function updateActiveUI(){
  if (pbActive?.startTime){
    const sIdx=findIdxByTime(pbActive.startTime);
    const eIdx=sIdx>=0?sIdx+10:-1;
    activeEl.textContent = pbActive.manual ? "MANUAL C0→C10" : "C0 → C10";
    const c0=sIdx>=0?fmtPrice(pbActive.startClose):"—";
    const c10=(eIdx>=0 && candles[eIdx])?fmtPrice(candles[eIdx].close):"—";
    activeSubEl.textContent=`C0 ${c0} • C10 ${c10}`;
  } else {
    activeEl.textContent="—";
    activeSubEl.textContent="C0 — • C10 —";
  }
}

/* chart */
const chart = { cv:$("cv"), ctx:null, dpr:1, panX:0, zoom:1, isDown:false, lastX:0, rightPadPct:0.15, baseBars:90 };

function drawLineSeries(ctx,start,end,pxPerBar,arr,yFn,stroke,width){
  ctx.strokeStyle=stroke; ctx.lineWidth=width||1.5;
  ctx.beginPath();
  for(let i=start;i<=end;i++){
    const x=(i-start)*pxPerBar+0.5;
    const yy=yFn(arr[i]);
    if(i===start) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
  }
  ctx.stroke();
}
function drawLabelBox(ctx,x,y,text,color){
  ctx.font="12px system-ui";
  const pad=6;
  const w=Math.ceil(ctx.measureText(text).width)+pad*2;
  const h=20;
  const rect=chart.cv.getBoundingClientRect();
  const W=rect.width, H=rect.height;
  const xx=Math.max(6,Math.min(x,W-w-6));
  const yy=Math.max(6,Math.min(y,H-h-6));
  ctx.fillStyle="rgba(0,0,0,0.60)";
  ctx.fillRect(xx,yy,w,h);
  ctx.strokeStyle="rgba(255,255,255,0.10)";
  ctx.strokeRect(xx+0.5,yy+0.5,w-1,h-1);
  ctx.fillStyle=color;
  ctx.fillText(text,xx+pad,yy+14);
}
function drawOneTrade(ctx,t,viewStart,viewEnd,pxPerBar,yFn,H){
  const isUp=t.dir==="UP";
  const col=isUp?"rgba(34,197,94,0.95)":"rgba(239,68,68,0.95)";
  const glyph=isUp?"▲":"▼";
  const safeY=(yy)=>Math.max(10,Math.min(H-10,yy));

  if (t.startIdx>=viewStart && t.startIdx<=viewEnd){
    const c0=candles[t.startIdx];
    const x0=(t.startIdx-viewStart)*pxPerBar + 6;
    const yAnchor=isUp?yFn(c0.low):yFn(c0.high);
    const y0=safeY(isUp?(yAnchor+22):(yAnchor-44));
    ctx.font="18px system-ui"; ctx.fillStyle=col;
    ctx.fillText(glyph,x0,y0+18);
    drawLabelBox(ctx,x0+18,y0+2,(t.manual?"C0 (M)":"C0"),"rgba(255,255,255,0.75)");
  }

  if (t.endIdx>=viewStart && t.endIdx<=viewEnd){
    const x10=(t.endIdx-viewStart)*pxPerBar + 10;
    const c10=candles[t.endIdx];
    if (t.outcome==="PENDING"){
      drawLabelBox(ctx,x10,8,"C10 …","rgba(255,255,255,0.35)");
    } else if (c10){
      const win=t.outcome==="WIN";
      const col10=win?"rgba(34,197,94,0.95)":"rgba(239,68,68,0.95)";
      const y10=safeY(yFn(c10.close));
      ctx.beginPath(); ctx.fillStyle=col10;
      ctx.arc(x10+2,y10-4,4,0,Math.PI*2); ctx.fill();
      const yLbl=(y10<H*0.5)?(y10+10):(y10-30);
      drawLabelBox(ctx,x10+12,yLbl,`C10 ${t.outcome}`,col10);
    }
  }
}

chart.draw = function(){
  const ctx=chart.ctx;
  const rect=chart.cv.getBoundingClientRect();
  const W=rect.width, H=rect.height;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle="rgba(0,0,0,0.10)";
  ctx.fillRect(0,0,W,H);

  const n=candles.length;
  if (n<10) return;

  const bars=Math.max(30,Math.floor(chart.baseBars/chart.zoom));
  const rightPadPx=Math.floor(W*chart.rightPadPct);
  const pxPerBar=(W-rightPadPx)/bars;

  const shiftBars=Math.round(chart.panX/Math.max(2,pxPerBar));
  const end=(n-1)-shiftBars;
  const start=Math.max(0,end-bars+1);

  let hi=-Infinity, lo=Infinity;
  for(let i=start;i<=end;i++){
    const c=candles[i]; if(!c) continue;
    hi=Math.max(hi,c.high); lo=Math.min(lo,c.low);
  }
  if(!Number.isFinite(hi)||!Number.isFinite(lo)||hi===lo) return;
  const pad=(hi-lo)*0.08; hi+=pad; lo-=pad;
  const yFn=(p)=>{ const t=(p-lo)/(hi-lo); return H - t*H; };

  ctx.strokeStyle="rgba(255,255,255,0.05)"; ctx.lineWidth=1;
  for(let gx=0;gx<=10;gx++){ const xg=(gx/10)*W; ctx.beginPath(); ctx.moveTo(xg,0); ctx.lineTo(xg,H); ctx.stroke(); }
  for(let gy=0;gy<=6;gy++){ const yg=(gy/6)*H; ctx.beginPath(); ctx.moveTo(0,yg); ctx.lineTo(W,yg); ctx.stroke(); }

  if (emaFast.length===n) drawLineSeries(ctx,start,end,pxPerBar,emaFast,yFn,"rgba(200,210,225,0.35)",2.0);
  if (emaSlow.length===n) drawLineSeries(ctx,start,end,pxPerBar,emaSlow,yFn,"rgba(200,210,225,0.20)",1.6);

  for(let i=start;i<=end;i++){
    const c=candles[i];
    const x0=(i-start)*pxPerBar;
    const cx=x0+0.5;
    const o=yFn(c.open), cl=yFn(c.close), h=yFn(c.high), l=yFn(c.low);
    const isUp=c.close>=c.open;

    ctx.strokeStyle="rgba(255,255,255,0.16)";
    ctx.beginPath(); ctx.moveTo(cx,h); ctx.lineTo(cx,l); ctx.stroke();

    const bw=Math.max(3,pxPerBar*0.55);
    const bx=cx-bw/2;
    const top=Math.min(o,cl);
    const bh=Math.max(2,Math.abs(cl-o));
    ctx.fillStyle=isUp?"rgba(34,197,94,0.95)":"rgba(239,68,68,0.95)";
    ctx.fillRect(bx,top,bw,bh);
  }

  const drawList=[];
  if (pbActive?.startTime){
    const sIdx=findIdxByTime(pbActive.startTime);
    if (sIdx>=0) drawList.push({dir:pbActive.dir,startIdx:sIdx,endIdx:sIdx+10,outcome:"PENDING",manual:!!pbActive.manual});
  }
  for (const t of pbTrades.slice(-2)){
    const sIdx=findIdxByTime(t.startTime);
    const eIdx=findIdxByTime(t.endTime);
    if (sIdx>=0 && eIdx>=0) drawList.push({dir:t.dir,startIdx:sIdx,endIdx:eIdx,outcome:t.outcome,manual:!!t.manual});
  }
  for (const t of drawList){
    if (t.endIdx<start || t.startIdx>end) continue;
    drawOneTrade(ctx,t,start,end,pxPerBar,yFn,H);
  }

  ctx.fillStyle="rgba(0,0,0,0.18)";
  ctx.fillRect(W-rightPadPx,0,rightPadPx,H);
  ctx.strokeStyle="rgba(255,255,255,0.06)";
  ctx.beginPath(); ctx.moveTo(W-rightPadPx,0); ctx.lineTo(W-rightPadPx,H); ctx.stroke();
};

function chartResize(){
  const rect=chart.cv.getBoundingClientRect();
  chart.dpr=Math.max(1,window.devicePixelRatio||1);
  chart.cv.width=Math.floor(rect.width*chart.dpr);
  chart.cv.height=Math.floor(rect.height*chart.dpr);
  chart.ctx.setTransform(chart.dpr,0,0,chart.dpr,0,0);
  chart.draw();
}
chart.ctx = chart.cv.getContext("2d");
new ResizeObserver(()=>chartResize()).observe(chart.cv);
window.addEventListener("resize", ()=>chartResize());

chart.cv.addEventListener("mousedown",(e)=>{ chart.isDown=true; chart.lastX=e.clientX; },{passive:true});
window.addEventListener("mouseup",()=>{ chart.isDown=false; },{passive:true});
window.addEventListener("mousemove",(e)=>{
  if(!chart.isDown) return;
  const dx=e.clientX-chart.lastX; chart.lastX=e.clientX;
  chart.panX += dx; chart.draw();
},{passive:true});
chart.cv.addEventListener("wheel",(e)=>{
  e.preventDefault();
  const rect=chart.cv.getBoundingClientRect();
  const mx=e.clientX-rect.left;
  const before=chart.zoom;
  const delta=Math.sign(e.deltaY);
  chart.zoom = clamp(chart.zoom*(delta>0?0.92:1.08),0.6,6);
  const k=chart.zoom/before;
  chart.panX=(chart.panX-mx)*k+mx;
  chart.draw();
},{passive:false});
chart.cv.addEventListener("dblclick",()=>{ chart.panX=0; chart.zoom=1; chart.draw(); },{passive:true});

btnResetView.addEventListener("click",()=>{ chart.panX=0; chart.zoom=1; chart.draw(); });
btnClearTrade.addEventListener("click",()=>{ clearActive(); updateActiveUI(); chart.draw(); });

/* ws */
let tickerWS=null, klineWS=null;
function setWsState(state){
  wsStateEl.textContent=state;
  if (state==="OPEN"){ wsDot.classList.add("on"); wsDot.classList.remove("off"); feedEl.textContent="LIVE"; }
  else if (state==="CLOSED"||state==="ERROR"){ wsDot.classList.remove("on"); wsDot.classList.add("off"); feedEl.textContent="OFF"; }
  else { wsDot.classList.remove("on"); wsDot.classList.remove("off"); feedEl.textContent="—"; }
}
function connectTicker(){
  if (tickerWS) try{tickerWS.close();}catch{}
  tickerWS=new WebSocket(`${WS_BASE}/${CONFIG.SYMBOL_WS}@ticker`);
  tickerWS.onopen=()=>{ setWsState("OPEN"); statusEl.textContent="WS live (ticker + kline)."; };
  tickerWS.onmessage=(e)=>{
    try{
      const d=JSON.parse(e.data);
      const p=Number(d.c);
      const chg=Number(d.P);
      if (Number.isFinite(p)){
        if (!Number.isFinite(lastTickPrice)) setDir("flat");
        else if (p>lastTickPrice) setDir("up");
        else if (p<lastTickPrice) setDir("down");
        else setDir("flat");
        lastTickPrice=p;
        priceEl.textContent=fmtPrice(p);
      }
      if (Number.isFinite(chg)){
        const s=`${chg>=0?"+":""}${chg.toFixed(2)}%`;
        setTextColored(chg24hEl,s, chg>0?"up":chg<0?"down":"flat");
      }
      timeEl.textContent=istTimeStr();
    }catch{}
  };
  tickerWS.onclose=()=>{ setWsState("CLOSED"); setTimeout(connectTicker,1500); };
  tickerWS.onerror=()=>{ setWsState("ERROR"); };
}
function connectKline(){
  if (klineWS) try{klineWS.close();}catch{}
  klineWS=new WebSocket(`${WS_BASE}/${CONFIG.SYMBOL_WS}@kline_${CONFIG.KLINE_INTERVAL}`);
  klineWS.onmessage=(e)=>{
    try{
      const msg=JSON.parse(e.data);
      const k=msg.k;
      const bar={time:k.t,open:Number(k.o),high:Number(k.h),low:Number(k.l),close:Number(k.c),volume:Number(k.v),closed:!!k.x};

      const last=candles[candles.length-1];
      if (last && last.time===bar.time){
        candles[candles.length-1]={...last,...bar};
        rebuildEMAs();
        computeTrendAndSetup();
        updateActiveUI();
        chart.draw();
      } else if (!last || bar.time>last.time){
        candles.push(bar);
        if (candles.length>360) candles.shift();
        rebuildEMAs();
        if (bar.closed) volPush(bar.volume); else volReset();

        if (bar.closed){
          maybeAutoLead();
          updateOutcome();
          updateDeltas();
          computeTrendAndSetup();
          updateActiveUI();
        } else {
          computeTrendAndSetup();
        }
        chart.draw();
      }
    }catch{}
  };
  klineWS.onclose=()=>setTimeout(connectKline,1500);
}

async function warmup(){
  try{
    const url=`${REST_KLINES}?symbol=${CONFIG.SYMBOL_REST}&interval=${CONFIG.KLINE_INTERVAL}&limit=220`;
    const res=await fetch(url);
    if (!res.ok) throw new Error(`REST ${res.status}`);
    const raw=await res.json();
    candles=raw.map(k=>({time:k[0],open:Number(k[1]),high:Number(k[2]),low:Number(k[3]),close:Number(k[4]),volume:Number(k[5]),closed:true}));
    rebuildEMAs();
    volReset();
    updateDeltas();
    computeTrendAndSetup();
    updateActiveUI();
    chart.draw();
    statusEl.textContent="REST warmup OK • waiting WS…";
  } catch (err){
    statusEl.textContent=`REST warmup failed (${String(err)}) • WS will warm up (needs 60 candles for full logic).`;
  }
}

async function start(){
  setWsState("CONNECTING");
  timeEl.textContent=istTimeStr();
  await warmup();
  connectTicker();
  connectKline();
  setInterval(()=>{ timeEl.textContent=istTimeStr(); }, 800);
  setInterval(()=>{ computeTrendAndSetup(); }, 1200);
}
start();
</script>
</body>
</html>